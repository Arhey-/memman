<head>
	<meta content="width=device-width, initial-scale=1" name="viewport">
	<meta name="color-scheme" content="dark light">
	<style>
		:root {
			--repeat: auto-fit;
		}

		body {
			color: #ccc;
			background-color: #333;
			margin: 0;
		}

		#cards {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
		}

		#cards>.div {
			grid-column: 1/-1;
		}

		a {
			position: relative;
		}

		a>p {
			color: white;
			background-color: rgba(0, 0, 0, 0.3);
			margin: 5px;
			position: absolute;
			font-size: calc(1rem / var(--repeat));
		}

		.tags {
			bottom: 0;
			right: 0;
		}

		a>img {
			width: 100%;
			aspect-ratio: 16 / 9;
		}

		a.next {
			border: 1px solid green;
		}

		a.next.gap {
			border-style: dashed;
		}

		a.select {
			border: 1px solid blue;
		}

		#tool {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
			position: sticky;
			bottom: 0;
		}

		button {
			font-size: 1rem;
		}

		#tagsInc {
			background-color: #385539;
		}

		textarea {
			grid-column: 1/-1;
		}

		textarea:focus {
			height: 12em;
		}
	</style>
</head>

<div id="cards"></div>
<div id="tool">
	<textarea placeholder="eval">
//prevent eval -- uncomment to don't eval
// top()
// last()
// view()
// pull(localStorage.getItem('tempItems'), [])
// download()
	</textarea>
	<input id="perRow" type='number' placeholder='auto-fit' />
	<label><input type="checkbox" id="prev">prev</label>
	<label><input type="checkbox" id="select">select</label>
	<select id="tagsInc" multiple></select>
	<button id="show">show</button>
</div>

<script type="module">
	import { downloadJsonString } from './download.js';
	import { html } from '../lib/html.js';
	import { DB } from '../lib/db.js';

	addEventListener('error', e => log(e.message));
	function log(...t) {
		document.body.append(html.p(null, ...t)); // TODO [x]
	}

	function subtractSet(set, subs) {
		const ss = new Set(set)
		for (const s of subs) ss.delete(s)
		return ss
	}

	const $ = selector => document.querySelector(selector);
	const $$ = selector => document.querySelectorAll(selector);
	const card = i => html.a(
		{ href: i.url, target: '_blank', class: { next: i.prev, gap: i[prevGap] } },
		html.p(i.name || i.title),
		html.img({ src: i.src, loading: 'lazy' }),
		html.p({ class: 'tags' }, [
			...subtractSet(i.tags, [...$tagsInc.selectedOptions].map(o => o.value))
		].toString())
	);
	const $cards = $('#cards'), $tagsInc = $('#tagsInc')
	const top = () => $cards.scrollIntoView();
	const last = () => $cards.lastElementChild.scrollIntoView();
	function view(urlPart) {
		if (!urlPart) prompt('part of url')
		if (urlPart) [...document.querySelectorAll('a')]
			.find(a => a.href.includes(urlPart))
			?.scrollIntoView()
	}

	const $textarea = $('textarea')
	$textarea.onchange = () => {
		// add in-string check?
		const s = $textarea.value.replace(/ ([A-Z])/g, '$1')
		if (!s || s.startsWith('prevent eval')) return;
		const r = eval(s)
		if (r instanceof Promise) r.then(log).catch(log);
		else log(r);
	}

	const db = new DB('links', 1, (/** @type {IDBVersionChangeEvent} */ e) => {
		if (e.oldVersion == 0 && e.newVersion == 1) {
			const db = event.target.result;
			const s = db.createObjectStore('links', { keyPath: 'url' });
			// s.createIndex('tags', 'tags', { unique: false }); // multi
		} else {
			throw Error(`todo uprade db from v${e.oldVersion} to ${e.newVersion}`)
		}
	})
	await db.ready

	localStorage.getItem('links-tags')
		?.split(',')
		.forEach(t => $tagsInc.append(html.option({ value: t }, t)))
	$('#show').onclick = () => (async () => {
		$cards.innerHTML = ''
		const inc = [...$tagsInc.selectedOptions].map(o => o.value)
		const links = [], allTags = new Set
		await db.each('links', l => {
			if (inc.every(t => l.tags.includes(t))) links.push(l) //TODO search
			l.tags.forEach(t => allTags.add(t))
		})
		const s = [...allTags].sort().toString()
		if (s != localStorage.getItem('links-tags')) {
			localStorage.setItem('links-tags', s)
			const was = [...$tagsInc.options].map(o => o.value)
			for (const t of allTags) {
				if (!was.includes(t)) $tagsInc.append(html.option({ value: t }, t))
			}
		}
		$cards.append(...prevMods(sort(links)).map(card));
	})().catch(log)

	const $perRow = $('#perRow');
	$perRow.onchange = e => {
		const v = $perRow.value;
		document.documentElement.style.setProperty('--repeat', v || 'auto-fit');
		$cards.style['grid-template-columns'] = v
			? 'repeat(var(--repeat), 1fr)'
			: '';
		if (e) localStorage.setItem('links-columns', v);
	};
	$perRow.value = localStorage.getItem('links-columns') || '';
	$perRow.onchange();

	const $select = $('#select')
	$select.onchange = () => {
		if (!$select.checked) $$('.select')
			.forEach(e => e.classList.remove('select'))
	}
	const $prev = $('#prev')
	let beNext
	$prev.onchange = () => {
		if ($prev.checked || !beNext) return;
		beNext.style.border = ''
		beNext = null
	}
	document.body.addEventListener('click', e => {
		const a = e.target?.parentElement
		if ('A' != a?.tagName || !($prev.checked || $select.checked)) return;
		e.preventDefault()
		if ($select.checked) return a.classList.toggle('select')
		if (beNext) {
			const next = beNext
			beNext.style.border = ''
			beNext = null
			if (a == next) return;
			db.update('links', next.href, { prev: a.href }).then(() => {
				a.after(next)
				next.classList.add('next')
			}).catch(log)
		} else {
			beNext = a
			a.style.border = '1px solid blue'
		}
	})

	function sort(list) {
		let wait, s = [], label = `sort ${list.length} items`;
		console.time(label);
		do {
			if (wait) list = wait;
			wait = [];
			for (const i of list) {
				if (!i.prev) {
					s.push(i);
					continue;
				}
				const n = s.findIndex(si => si.url == i.prev);
				if (n > -1) {
					s.splice(n + 1, 0, i);
				} else if (list.some(li => li.url == i.prev)) {
					wait.push(i);
				} else {
					s.push(i);
				}
			}
		} while (wait.length);
		console.timeEnd(label);
		return s
	}

	const prevGap = Symbol('prevGap')
	function prevMods(list) {
		const urls = new Set(list.map(l => l.url))
		list.forEach((l, i) => {
			if (l.prev && l.prev != list[i - 1]?.url) l[prevGap] = true
		})
		return list
	}

	addEventListener('message', async e => {
		log(`message ${e.data?.url || e.data}`)
		document.body.append(html.input({
			placeholder: 'new tags',
			onchange(e) {
				const tags = e.target.value
					.split(' ')
					.flatMap(s => s.split(','))
					.map(s => s.trim())
					.filter(Boolean)
				if (!tags.length) return;
				const was = [...$tagsInc.options].map(o => o.value)
				for (const t of tags) {
					if (!was.includes(t)) $tagsInc.append(html.option({ value: t }, t))
				}
				const s = [...new Set([...was, ...tags])].sort().toString()
				if (s != localStorage.getItem('links-tags')) {
					localStorage.setItem('links-tags', s)
				}
			}
		}));
		const { url, src, name, title } = e.data
		const i = await db.get('links', url)
		if (!i) {
			$cards.append(card(e.data))
			const b = html.button(async () => {
				const tags = [...$tagsInc.selectedOptions].map(o => o.value)
				if (!tags.length) return log('select least one tag')
				b.remove()
				const link = { url, src, name: name || title, tags }
				await db.add('links', link)
				log('saved\n' + url)
			}, 'add');
			document.body.append(b);
			return
		}
		$cards.append(card(i))
		log(`already in ${i.tags}`);
		[...$tagsInc.options].forEach(o => o.selected = i.tags.includes(o.value))
		const b = html.button(async () => {
			b.remove()
			await db.delete('links', url)
			log(`"${name || title}" removed\n${url}`)
		}, 'remove?')
		const bSrc = html.button(async () => {
			bSrc.remove()
			await db.update('links', url, { src })
			log('src updated')
		}, 'update src')
		const bTags = html.button(async () => {
			const tags = [...$tagsInc.selectedOptions].map(o => o.value)
			if (!tags.length) return log('select least one tag')
			const { eqSet } = await import('../lib/diff.js')
			if (eqSet(tags, i.tags)) return;
			bTags.disabled = true
			await db.update('links', url, { tags })
			i.tags = tags
			bTags.disabled = false
			log('tags updated')
		}, 'update tags')
		document.body.append(b, bTags, bSrc);
	});
	opener?.postMessage('ready', '*');

	async function download() {
		const d = new Date().toISOString().slice(2, 10)
		const name = prompt('{name}.json', 'links_' + d)
		if (!name) return;
		const ls = await db.getAll('links')
		log(`export ${ls.length} links`)
		downloadJsonString(JSON.stringify(ls), `${name}.json`); // TODO 
	}

	async function pull(olds, addTags = []) {
		if (!Array.isArray(addTags)) addTags = []
		addTags.filter(Boolean)
		if (typeof olds == 'string') olds = JSON.parse(olds)
		if (!olds) return;
		const count = { all: olds.length, upTags: 0, upPrev: 0 }
		for (const o of olds) {
			const link = await db.get('links', o.url)
			if (!link) continue;
			if (addTags.some(t => !link.tags.includes(t))) {
				const tags = [...new Set([...link.tags, ...addTags])]
				await db.update('links', o.url, { tags })
				count.upTags++
			}
			if (!o.prev || link.prev == o.prev) continue;
			if (!link.prev) {
				await db.update('links', o.url, { prev: o.prev })
				count.upPrev++
			}
			const ls = await Promise.all([
				db.get('links', link.prev),
				link,
				db.get('links', o.prev),
				link,
			])
			$cards.append(ls.map(card), html.p({ class: 'div' }))
		}
		log('pull done ' + Object.entries(count).map(p => p.join(' ')))
	}
</script>
