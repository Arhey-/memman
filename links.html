<head>
	<meta content="width=device-width, initial-scale=1" name="viewport">
	<meta name="color-scheme" content="dark light">
	<style>
		:root {
			--repeat: auto-fit;
		}

		body {
			color: #ccc;
			background-color: #333;
			margin: 0;
		}

		#cards {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
		}

		a {
			position: relative;
		}

		a>p {
			color: white;
			background-color: rgba(0, 0, 0, 0.3);
			margin: 5px;
			position: absolute;
			font-size: calc(1rem / var(--repeat));
		}

		a>img {
			width: 100%;
			aspect-ratio: 16 / 9;
		}

		a.next {
			border: 1px solid green;
		}

		#tool {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
			position: sticky;
			bottom: 0;
		}

		button {
			font-size: 1rem;
		}

		#tagsInc {
			background-color: #385539;
		}

		textarea {
			grid-column: 1/-1;
		}

		textarea:focus {
			height: 12em;
		}
	</style>
</head>

<div id="cards"></div>
<div id="tool">
	<textarea placeholder="eval">
//prevent eval -- uncomment to don't eval on change
// top()
// last()
// view()
// migrate(localStorage.getItem('tempItems'), ['tmp']).catch(log)
	</textarea>
	<button id="export">export</button>
	<input id="perRow" type='number' placeholder='auto-fit' />
	<label><input type="checkbox" id="prev">prev</label>
	<select id="tagsInc" multiple></select>
	<button id="show">show</button>
</div>

<script type="module">
	import { downloadJsonString } from './download.js';
	import { html } from '../lib/html.js';
	import { DB } from '../lib/db.js';

	addEventListener('error', e => log(e.message));
	function log(...t) {
		document.body.append(html.p(null, ...t));
	}

	const $ = selector => document.querySelector(selector);
	const card = i => html.a(
		{ href: i.url, target: '_blank', className: i.prev ? 'next' : '' },
		html.p(i.name || i.title),
		html.img({ src: i.src, loading: 'lazy' })
	);
	const $cards = $('#cards'), $tagsInc = $('#tagsInc')
	const top = () => $cards.scrollIntoView();
	const last = () => $cards.lastElementChild.scrollIntoView();
	function view(urlPart) {
		if (!urlPart) prompt('part of url')
		if (urlPart) [...document.querySelectorAll('a')]
			.find(a => a.href.includes(urlPart))
			?.scrollIntoView()
	}

	const $textarea = $('textarea')
	$textarea.onchange = () => {
		const s = $textarea.value
		if (s && !s.startsWith('prevent eval')) log(eval(s))
	}

	const db = new DB('links', 1, (/** @type {IDBVersionChangeEvent} */ e) => {
		if (e.oldVersion == 0 && e.newVersion == 1) {
			const db = event.target.result;
			const s = db.createObjectStore('links', { keyPath: 'url' });
			// s.createIndex('tags', 'tags', { unique: false }); // multi
		} else {
			throw Error(`todo uprade db from v${e.oldVersion} to ${e.newVersion}`)
		}
	})
	await db.ready

	localStorage.getItem('links-tags')
		?.split(',')
		.forEach(t => $tagsInc.append(html.option({ value: t }, t)))
	$('#show').onclick = async () => {
		$cards.innerHTML = ''
		const inc = [...$tagsInc.selectedOptions].map(o => o.value)
		const links = [], allTags = new Set
		await db.each('links', l => {
			if (inc.every(t => l.tags.includes(t))) links.push(l)
			l.tags.forEach(t => allTags.add(t))
		})
		const s = [...allTags].sort().toString()
		if (s != localStorage.getItem('links-tags')) {
			localStorage.setItem('links-tags', s)
			const was = [...$tagsInc.options].map(o => o.value)
			for (const t of allTags) {
				if (!was.includes(t)) $tagsInc.append(html.option({ value: t }, t))
			}
		}
		for (const i of sort(links)) {
			$cards.append(card(i));
		}
	}
	$('#export').onclick = () => {
		const d = new Date().toLocaleDateString('eu').split('.').reverse().join('_')
		const name = prompt('{name}.json', 'links_' + d.slice(2))
		if (!name) return;
		db.getAll('links').then(ls => {
			log(`export ${ls.length} links`)
			downloadJsonString(JSON.stringify(ls), `${name}.json`); // TODO 
		}).catch(log)
	}

	const $perRow = $('#perRow');
	$perRow.onchange = e => {
		const v = $perRow.value;
		document.documentElement.style.setProperty('--repeat', v || 'auto-fit');
		$cards.style['grid-template-columns'] = v
			? 'repeat(var(--repeat), 1fr)'
			: '';
		if (e) localStorage.setItem('links-columns', v);
	};
	$perRow.value = localStorage.getItem('links-columns') || '';
	$perRow.onchange();

	const $prev = $('#prev')
	let beNext
	$prev.onchange = () => {
		if ($prev.checked || !beNext) return;
		beNext.style.border = ''
		beNext = null
	}
	document.body.addEventListener('click', e => {
		if (!$prev.checked || 'A' != e.target.parentElement.tagName) return;
		e.preventDefault()
		const a = e.target.parentElement
		if (beNext) {
			const next = beNext
			beNext.style.border = ''
			beNext = null
			if (a == next) return;
			db.update('links', next.href, { prev: a.href }).then(() => {
				a.after(next)
				next.classList.add('next')
			}).catch(log)
		} else {
			beNext = a
			a.style.border = '1px solid blue'
		}
	})

	function sort(list) {
		let wait, s = [], label = `sort ${list.length} items`;
		console.time(label);
		do {
			if (wait) list = wait;
			wait = [];
			for (const i of list) {
				if (!i.prev) {
					s.push(i);
					continue;
				}
				const n = s.findIndex(si => si.url == i.prev);
				if (n > -1) {
					s.splice(n + 1, 0, i);
				} else if (list.some(li => li.url == i.prev)) {
					wait.push(i);
				} else {
					s.push(i);
				}
			}
		} while (wait.length);
		console.timeEnd(label);
		return s
	}

	addEventListener('message', async e => {
		log(`message ${e.data?.url || e.data}`)
		document.body.append(html.input({
			placeholder: 'new tags',
			onchange(e) {
				const tags = e.target.value
					.split(' ')
					.flatMap(s => s.split(','))
					.map(s => s.trim())
					.filter(Boolean)
				if (!tags.length) return;
				const was = [...$tagsInc.options].map(o => o.value)
				for (const t of tags) {
					if (!was.includes(t)) $tagsInc.append(html.option({ value: t }, t))
				}
				const s = [...new Set([...was, ...tags])].sort().toString()
				if (s != localStorage.getItem('links-tags')) {
					localStorage.setItem('links-tags', s)
				}
			}
		}));
		const { url, src, name, title } = e.data
		const i = await db.get('links', url)
		if (!i) {
			$cards.append(card(e.data))
			const b = html.button(async () => {
				const tags = [...$tagsInc.selectedOptions].map(o => o.value)
				if (!tags.length) return alert('select least one tag')
				b.remove()
				const link = { url, src, name: name || title, tags }
				await db.add('links', link)
				log('saved\n' + url)
			}, 'add');
			document.body.append(b);
			return
		}
		log(`already in ${i.tags}`);
		[...$tagsInc.options].forEach(o => o.selected = i.tags.includes(o.value))
		const b = html.button(async () => {
			b.remove()
			await db.delete('links', url)
			log(`"${name || title}" removed\n${url}`)
		}, 'remove?')
		const bSrc = html.button(async () => {
			bSrc.remove()
			await db.update('links', url, { src })
			log('src updated')
		}, 'update src')
		const bTags = html.button(async () => {
			const tags = [...$tagsInc.selectedOptions].map(o => o.value)
			if (!tags.length) return alert('select least one tag')
			const { eqSet } = await import('../lib/diff.js')
			if (eqSet(tags, i.tags)) return;
			bTags.disabled = true
			await db.update('links', url, { tags })
			i.tags = tags
			bTags.disabled = false
			log('tags updated')
		}, 'update tags')
		document.body.append(b, bTags, bSrc);
	});
	opener?.postMessage('ready', '*');

	//
	async function migrate(olds, addTags) {
		if (!Array.isArray(addTags) || !addTags.length || addTags.some(t => !t)) {
			throw 'addTags must be array'
		}
		if (typeof olds == 'string') olds = JSON.parse(olds)
		if (!olds) return;
		const count = { all: olds.length, add: 0, upTags: 0, upPrev: 0 }
		for (const o of olds) {
			const link = await db.get('links', o.url)
			if (!link) {
				if (o.title) {
					o.name = o.title
					delete o.title
				}
				await db.add('links', { ...o, tags: addTags })
				count.add++
				continue
			}
			if (addTags.some(t => !link.tags.includes(t))) {
				const tags = [...new Set([...link.tags, ...addTags])]
				await db.update('links', o.url, { tags })
				count.upTags++
			}
			if (!o.prev || link.prev == o.prev) continue;
			if (!link.prev) {
				await db.update('links', o.url, { prev: o.prev })
				count.upPrev++
			}
			log(
				html.a({ href: link.url }, 'link'),
				'.',
				html.a({ href: link.prev }, 'prev'),
				' conflict ',
				' ',
				html.a({ href: o.prev }, 'old.prev')
			)
		}
		log('migrate done ' + Object.entries(count).map(p => p.join(' ')))
	}
</script>
